import { useState, useCallback, useEffect } from 'react';
import { supabase } from '@/integrations/supabase/client';
import { useToast } from '@/hooks/use-toast';
import { useNotifications } from '@/hooks/useNotifications';

export interface Signal {
  id: string;
  pair: string;
  direction: 'long' | 'short';
  entry: number;
  tp1: number;
  tp2: number;
  tp3: number;
  sl: number;
  confidence: 'Low' | 'Medium' | 'High';
  reasoning: string;
  expiresAt: string;
  createdAt: string;
}

export function useAISignals() {
  const [signals, setSignals] = useState<Signal[]>([]);
  const [loading, setLoading] = useState(false);
  const [error, setError] = useState<string | null>(null);
  const { toast } = useToast();
  const { notifySignal } = useNotifications();

  const generateSignals = useCallback(async () => {
    setLoading(true);
    setError(null);

    try {
      const { data, error: invokeError } = await supabase.functions.invoke('generate-signals');
      
      if (invokeError) {
        console.error('Error invoking generate-signals:', invokeError);
        throw invokeError;
      }

      if (data.error) {
        throw new Error(data.error);
      }

      const newSignals = data.signals as Signal[];
      setSignals(newSignals);

      // Notify about high-confidence signals
      const highConfidenceSignals = newSignals.filter(s => s.confidence === 'High');
      if (highConfidenceSignals.length > 0) {
        const topSignal = highConfidenceSignals[0];
        const profitPotential = topSignal.direction === 'long' 
          ? ((topSignal.tp2 - topSignal.entry) / topSignal.entry) * 100
          : ((topSignal.entry - topSignal.tp2) / topSignal.entry) * 100;
        notifySignal(topSignal.pair, topSignal.direction, profitPotential);
      }

      toast({
        title: 'Signals Generated',
        description: `${newSignals.length} trading signals generated by AI`,
      });
    } catch (err: any) {
      console.error('Error generating signals:', err);
      setError(err.message);
      toast({
        title: 'Error',
        description: err.message || 'Failed to generate signals',
        variant: 'destructive',
      });
    } finally {
      setLoading(false);
    }
  }, [toast, notifySignal]);

  // Auto-refresh signals when they expire
  useEffect(() => {
    if (signals.length === 0) return;

    const checkExpiry = setInterval(() => {
      const now = new Date().getTime();
      const activeSignals = signals.filter(s => new Date(s.expiresAt).getTime() > now);
      
      if (activeSignals.length < signals.length) {
        setSignals(activeSignals);
        
        // Auto-generate new signals when count drops below 5
        if (activeSignals.length < 5) {
          generateSignals();
        }
      }
    }, 1000);

    return () => clearInterval(checkExpiry);
  }, [signals, generateSignals]);

  const getTimeRemaining = useCallback((expiresAt: string): string => {
    const now = new Date().getTime();
    const expiry = new Date(expiresAt).getTime();
    const diff = Math.max(0, expiry - now);
    
    const minutes = Math.floor(diff / 60000);
    const seconds = Math.floor((diff % 60000) / 1000);
    
    if (diff === 0) return 'Expired';
    if (minutes > 0) return `${minutes}m ${seconds}s`;
    return `${seconds}s`;
  }, []);

  return {
    signals,
    loading,
    error,
    generateSignals,
    getTimeRemaining,
  };
}